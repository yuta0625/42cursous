#size_tに関して
ｰ>C言語の標準ライブラリ関数では、「サイズ」や「長さ」を引数にとる。
ｰ>メモリ上のバイト数や配列の要素数を表すための整数である
ｰ>size_tはunisigned(符号なし)である。(負の値をもたない)
このsize_tを使用する場合には<stddef.h> をincludeしてくる
ヘッダーないでは次のように定義がされている。
typedef unsigned long size_t;
ｰ>printfで表したいときはsize_tなので、long型のため、%ldで表す

memsetの再実装
void	*memset(void *s, int c, size_t n)
汎用ポインタ(void *)に関して
汎用という単語の通り、あらゆるポインタ型に変換可能。ポインタ型であればどのような型でも受け取ることができる。
ｰ>char型やint型と異なり対象のサイズがないので用途に応じてキャストして使う。
void *ft_memsetの*はなになのか、またなぜreturn(s)をするのか
ｰ>戻り値の型がvoid型のポインタであるという関数
ｰ>return sは渡されたポインタをそのまま返すようになっている。
(解釈)
「先頭ポインタをもらって、指定バイト分埋めて、先頭アドレスをかえす」

memcpyとmemmoveの違いと使い分け
ｰ>両者の違いは「コピー先とコピー元が重なっているときの挙動の違い」
memcpy：メモリが重なっていない場合に使用。重複すると未定義動作。
memmove：重なっていても安全にコピーできる。
ｰ>メモリ領域上で同じ領域で被りが生じている場合でも安全にコピーすることができるということ

引数cを、論理和（&演算子）を使ってunsigned charと同じ0～255の範囲にする。
->引数cを&演算子で0xff(これ自体は16進数である)（10進数で255）と論理積を取ることで、unsigned char型と同じ0〜255の範囲に収めることができる。

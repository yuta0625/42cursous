exit関数について
プログラムの終了を明示的に指示するためにexit関数が使用されます。特に、大規模なプログラムやエラー処理が重要なシステムでは、exit関数を適切に使用することで、プログラムの状態を明示的にシステムに伝えることが可能

exitは#include <stdlib.h>に定義されている
exit(0) :プログラムが正常に終了したことをシステムに示します。プログラムが期待通りに実行された際に使用されます
exit(1) :非ゼロの値は、プログラムが異常終了したことを示します。エラーが発生した場合などに利用されます。

標準エラー出力に「Error」と表示し、その直後に'\n'を追加する必要がある。
write(2, "Error\n", 6)
exit(1)

引数の受け取り方について
"2 3 4" -> これは通す
2 3 4 -> これは通す
2 "3" 4 -> これは通す
先にソートをしておいて
本番のソートを行う

基数ソートを利用して実装を考える

基数ソートについてのまとめ
一言でいうと「数字の「桁」ごとに注目をして並び替えるアルゴリズム」である。
「基数」＝Radixは、10進数でいう「10」、2進数でいう「2」のような「位取りの基準となる数」
一般的なソート(クイックソートなど)が「2つの数値を比較して大小を決める」のに対し、　基数ソートは「比較を行わない」のが大きな特徴である。

最も一般的なLSD法、つまり「1の位(下の桁)から順に」並び替えていく方法
例：「170, 45, 75, 90, 802, 24, 2, 66」を昇順(小さい順)に並べたい
１の位の桁数をみてまず並び替える
10の位の桁数をみて並び替える
100の位の桁数をみて並び替える

これからやって行かないなけれいけないこと
push_swapでradix(2進数)を使うのは王道で使えるものである。
・10進数の基数ソートは「0〜9のバケツ」が必要そうにみえる。
これは10進数の場合は、0〜9に分けて振り分けていくような形で行うためである。
・しかし、　push_swapはスタックが2つ(A/B)しかない
・だから２進(bit)で0/1の2通りに分けるradixにする

先程とすこし流れを変えて実装を行っていく。
1.stack aの value をint配列arrにコピー
2.arrをソート
3.各ノードのvalueがarrの何番目か(二分探索)でindexを付与

この方針についての解説
その手順(座標圧縮)は非常に定石的なアプローチである。
arrはすでにソート済み（昇順）であるため、　「ある値targetがarrの何番目にあるか」を特定する二分探索の実装例である。

二分探索について(「半分ずつ消去法」なデータの探し方)
・データが順番に並んでいる前提で、まず真ん中のデータを取り出して「探しているデータは、これより大きい？」を確認
もし大きかったら、真ん中のデータとそれより小さいデータは全部消す。（もし小さい方だったら大きいほうを消す）
残ったデータの中から真ん中のデータを取り出して「探しているデータは、これより大きい？」を確認する。
というのを繰り返すことで、条件に合わないデータを半分ずつ消していって、目的のデータを見つける

二分探索の関数
下記の関数は、ソート済み配列arrの中からtargetを探し、見つかった場所のindexを返す

int get_rank_by_binary_search(int *arr, int size, int target)
{
	int left = 0;
	int right = size - 1;
	int mid;

	while (left <= right)
	{
		//中間のインデックスを計算
		//(left + right) / 2 でもいいが、オーバーフロー防止のためにこの書き方が安全である
		mid = left + (right - left) / 2;

		if (arr[mid] == target)
			return (mid);
		else if (arr[mid] < target)
			left = mid + 1;
		else
			right = mid - 1;
	}
	return (-1); //見つからなかった場合の処理
}

使い方のイメージ
void assign_indiceses(t_node *stack_a, int *sorted_arr, int size)
{
	t_node *current;
	current = stack_a;
	while (current != NULL)
	{
		current->index = get_rank_by_binary_search(sorted_arr, size, current->value);
		current = current->next;
	}
}

stack A自体はならび変えずに、Aの中身を一度だけ配列にコピーして並び替え、
その結果をつかってAの各ノードにindex(順位)を振る

クイックソートに関しての説明
ソートアルゴリズムの一つである。
・適当な数(ピヴォット)を選択する　(配列の中から基準となる数字を一つ選ぶ)
・ピヴォットより小さな要素の集合、大きい要素の集合に分割する
ｰ>ピボットより小さい数を左側へ。ピボットより大きい数を右側へ移動させる。
・２分割された各々の配列を、それぞれ分割できなくなるまで繰り返す
再帰で「左側のグループ」と「右側のグループ」に対して、同じ処理を繰り返す

クイックソートの実装に関して
void swap(int *a, int *b)
{
	int temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

//クイックソート本体
//arr:  ソートする配列
//left: 開始インデックス(通常は0)
//right: 終了インデックス(通常はsize - 1)

void quick_sort(int *arr, int left, int right)
{
	int pivot;
	int i;
	int j;

	//ベースケース：範囲が無効、または要素が一つの場合は何もなし
	if (left >= right)
		return ;

	//ピボットを選ぶ（ここでは範囲の真ん中の値）
	pivot = arr[(left + right) / 2];
	i = left;
	j = right;

	//左から見て、ピボット以上の値が見つかるまで進む
	while (arr[i] < pivot)
		i++;
	//右から見て、ピボット以下の値が見つかるまで戻る
	while (arr[j] > pivot)
		j--;

	//交換が必要なペアが見つかったらswapしてインデックスを進める
	if (i <= j)
	{
		swap(&arr[i], &arr[j]);
		i++;
		j--;
	}

	//再帰呼び出し
	//左側のグループ
	if (left < j)
		quick_sort(arr, left, j);
	if (i < right)
		quick_sort(arr, i, right);
}

基数ソート
キー値全体を比較せずに、キー値の一部のみを参照・比較を行い整列する方法
データの種類を特定しなければ、クイックソートが計算量で最速だが、
・ソート順を決めるキー値が整数
・整数値の範囲があらかじめわかっていて、それほど大きくない
という条件のもとならば基数ソートで計算量o(n)でソート可能である。

一言でいうと、「数字の桁」ごとに注目して並び替えるアルゴリズムである。
一般的なソートが「2つの値を比較して大小を決める」のに対し、基数ソートは「比較を行わない」のが大きな特徴である。
手順1：【1の位】だけで並べ替える

数字の末尾（1の位）だけを見て、バケツ（0〜9）に放り込むイメージで並べます。
    170, 90
    802, 2
    24
    45, 75
    66

並べ替え後： [170, 90, 802, 2, 24, 45, 75, 66] （※ここで重要なのは、**「安定ソート」**であることです。例えば170と90は、元の順番を保ったまま並びます）
手順2：【10の位】だけで並べ替える

次は10の位を見て並べ替えます。（桁がないものは0とみなします）
    802, 002 （10の位は0）
    024
    045
    066
    170, 075
    090

並べ替え後： [802, 2, 24, 45, 66, 170, 75, 90]
手順3：【100の位】だけで並べ替える

最後に100の位を見ます。
    002, 024, 045, 066, 075, 090 （これらは0）
    170
    802
並べ替え後（完了）： [2, 24, 45, 66, 75, 90, 170, 802]

max_index  = a->size - 1;
データが「座標圧縮」されて、0 〜 size-1の範囲の整数になっていると仮定する

ビット数の計算
max_bits = 0;
while ((max_index >> max_bits) != 0)
	max_bits++;
max_indexが0になるまで>>し続け、何回シフトできたかをmax_bitsにカウントします。
void	radix_sort(t_stack *a, t_stack *b)
{
	int	max_bits;
	int	max_index;
	int	bit;
	int	i;
	int	n;

	max_index = a->size -1;
	max_bits = 0;
	while ((max_index >> max_bits) != 0)
		max_bits++;
	bit = 0;
	//max_bits(最大ビット数)を使って、「下の桁(ビット)から順に、0と1にグループ分けを行う」
	while (bit++ < max_bits)
	{
		n = a->size;
		i = 0;
		while (i++ < n)
		{
			if (((a->top->index >> bit) & 1) == 0)
				pa(a, b);
			else
				ra(a);
		}
		while (b->size > 0)
			pa(a, b);
	}
}

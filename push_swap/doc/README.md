# Push_swap

**座標圧縮（Coordinate Compression）** と **基数ソート（Radix Sort）** を組み合わせ、データ構造には自作の **双方向循環リスト** を採用することで、計算効率と実行速度の最適化を実現しました。

## 概要

プログラムは引数として整数のリストを受け取り、`Stack A` に格納した後、`Stack B` を補助的に使用してソートを行います。入力されるデータ数に応じて最適なアルゴリズムを動的に選択し、命令数を最小限に抑えます。

## 設計とアルゴリズム
### 1. データ構造：双方向循環リスト
配列ではなく、**双方向循環リスト**を採用しました。
- **理由:** `push_swap` の操作（特に `ra`, `rra`）では、先頭と末尾の要素を頻繁に移動させます。循環リストを使用することで、ポインタの位置をずらすだけで回転操作が可能となり、**計算量 O(1)** で高速に処理できるためです。

### 2. 前処理：座標圧縮
ソートを行う前に、入力データを正規化（座標圧縮）しています。
- **Step 1:** 引数のパースとエラー処理（非整数、重複、INT範囲外のチェック）。
- **Step 2:** 配列をコピーし、**クイックソート（Quick Sort）** で整列。
- **Step 3:** **二分探索（Binary Search）** を使用して、スタック内の数値を「その数値が小さい方から何番目か」というランク（順位）に置き換え。
- **メリット:** 負の数や巨大な数値が含まれていても、データが `[0, N-1]` の範囲に収まるため、基数ソートが容易に実装可能になります。

### 3. ソート戦略

要素数 ($N$) に応じて処理を分岐させ、命令数（コスト）を最適化するハイブリッドなアプローチを採用しました。

#### 少数データ (N ≤ 5) -> 専用ロジックによる最適化
基数ソートはビットごとの走査が必要で固定コスト（オーバーヘッド）がかかるため、少数のデータには不向きです。
- **N = 3:** 条件分岐（ハードコーディング）により、最大2手以内でソート。
- **N = 5:** 最小値を `Stack B` に押し出す挿入ソート的な手法を採用。残りの3つをソートしてから戻すことで、12手以内を達成。

#### 大量データ (N > 5) -> ビット演算を用いた基数ソート (Radix Sort LSD)
データ量が多い場合は、計算量が安定している **LSD (Least Significant Digit) 基数ソート** を使用します。
- 座標圧縮済み（`0`〜`N-1`）のため、単純なビット演算で処理可能です。
- **ロジック:**
    1. 最下位ビットから順に注目する。
    2. ビットが `0` なら `Stack B` へプッシュ (`pb`)。
    3. ビットが `1` なら `Stack A` を回転 (`ra`)。
    4. その桁の処理が終わったら、`Stack B` の全要素を `Stack A` に戻す (`pa`)。
- これを最大ビット数まで繰り返すことで、**O(N * k)** の計算量で高速にソート完了します。


## 使い方

```bash
# コンパイル
make

# ランダムな数値で実行
./push_swap 4 67 3 87 23

# チェッカーを使用した確認例
ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker_OS $ARG

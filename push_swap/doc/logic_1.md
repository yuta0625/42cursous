全体の方針
stack Aにコマンドライン引数の値を入れる
stack Aの値を配列にコピーしてソートする
その配列を基準にして、stack Aの書くノードにindex(順位)を振り分ける
->ここまでを行うことができた。
次の課題としてそれのindexだけを見て基数ソートをできるようなアルゴリズムの構築を行う
indexだけをみて、基数ソート（２進）をstack A/stack Bでおこなう
・各ノードはindex = 0..N-1を持っている
・本番のソートはvalueではなくindexを使う
・使えるstackはAとBの2つである。
・基数ソートは2進数(0/1)でやる　ｰ>　bitごとの安定配分

2進　基数ソート(LSD radix)の考え方
「最下位bit(bit0) -> 次(bit1) -> ..」の順で、
毎回0と1に分けてから戻すを繰り返す
・bit0で分ける　ｰ> 偶数/奇数に並ぶ
・bit1で分ける -> ２の位でさらに整う
・...
・最終bitまでやると、indexの昇順になる

A/Bだけでやる"1bit分の処理”の核
Aの先頭をみて、そのbitが..
・0なら：pb (A->Bへ逃がす)
・1なら：ra (Aの先頭を末尾へ回す)
これをAの要素数n回繰り返す
最後に：
・Bに溜まったものを全部paでAに戻す
これで「bitが0のグループ」と「bitが1のグループ」がAの中で正しい相対順(安定性)を保ったまま並ぶ

どうして"ra"が必要なのか
pbすると要素がAから抜ける。
でもbitが１の要素はAに残したい。
ただしAの先頭ばかり見ていると、
・いつまでも同じ要素を見続けたり
・抜けた分だけ処理が偏ったり
が起きる
そこで、bitが1の要素はraして「見たことにして後ろは送る」
結果として,１周で必ずn回分処理できる。
循環リストのraは a->top = a->top->nextだけで成立するので相性がいい。

paで戻すの意味
bitが0だった要素はBに退避している。
bit処理の最後にpaでAに戻すと、
・0グループ(Bにいたもの)が先頭側にあつまり
・1グループ(Aでraされたもの)が後ろ側に残る

stack A自体は「まだ並び変えていない」
・配列でソートは準備
・命令(sa/pb/ra..)はまだ出していない

本番のソートはindexに対して行う
・value(元の数値)は一切比較しない
・radix sortはindexのbitだけを見る

stack Bは「一時置き場」
・bitが0->Bに逃す(pb)
・bitが1->Aで回す(ra)
・１周したらBを全部Aに戻す

(index >> bit)& 1で「その桁が0か1か」を直接調べる。
index >> bit
->indexを右にbit桁ずらす
＆１
ｰ>一番右のビット(最下位bit)だけ取り出す

radic sort(基数ソート)の1bit分の処理
if (((a->top->index >> bit) & 1) == 0)
	pb(a, b);
else
	ra(a);

これを全要素に対して行う
i = 0;
while (i < size)
{
	if (((a->top->index >> bit) & 1) == 0)
		pb(a, b);
	else
		ra(a);
	i++;
}

最後にBをAに戻す
while (b->size > 0)
	pa(a, b);

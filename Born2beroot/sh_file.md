なぜmonitoring.shの先頭に#!/bin/bashを書く必要があるのか。
#!/bin/bashはこのスクリプトをbashで実行しろというしてい
スクリプトはただのテキストなので、そのままだとどの”シェル”で解釈すべきかがわからない

今回この.shファイルの中をどのようにするのか
サーバー起動時、および10分ごとに(wallコマンドを参照)、このスクリプトは全端末に以下の情報を表示する。
エラーは一切表示されてはいけない。

・オペレーティングシステムのアーキテクチャとカーネルバージョン
ARCHITECTURE=$(uname -a)
出力例　Linux debian42 6.1.0-18-amd64 #1 SMP Debian 6.1.76-1 (2024-02-01) x86_64 GNU/Linux

・物理プロセッサの数
この物理プロセッサの数とは
ー＞物理プロセッサ＝CPUソケットの数(物理的にマザーボードに刺さっているCPUの数)
仮想マシン(VirtualBox)の場合はどのようになるのか？
仮想マシンはホスト(あなたのPC)にあるCPUを仮想的に見せているだけなので
->物理プロセッサは常に1になる
(Linuxのコードについて)
grep -F "pysical id" /proc/cpuinfo
->これだとすべてのcpuについてpysical id : 0が何回もでる
grep "physical id" /proc/cpuinfo | wc -l
->ユニークなpysical idは一つだけ(物理CPUは一個しかない)
0 0 0 0 0 0 0 -> これがユニーク化後だと　0
これが１行だからwc-lで１になる

• 仮想プロセッサの数。
grep processor /proc/cpuinfo　| wc -l

• サーバーの現在の利用可能なRAMとその使用率（パーセンテージ）。
free --mega
->メモリ状況をMB単位で表示をする
awk '$1 == "Mem:" {print $3}'
 ・$1 == "Mem:" -> 先頭の列がMem:の行を選ぶ
 ・{print $3} -> その行の3番目の列(=usedメモリ)を出力
上記のようなlinuxコマンドの使い方がawkの使い方になる
ram_total=$(free --mega | awk '$1 == "Mem:" {print $2}')
->総RAM容量(MB)
ram_use=$(free --mega | awk '$1 == "Mem:" {print $3}')
->使用中RAM容量
ram_percent=$(free --mega | awk '$1 == "Mem:" {printf("%.2f\n"), $3/$2*100}')
->使用率(使用中/総容量×100)を2桁少数で表示
printf("%.2f")にかんしては少数点二桁で数値を表示するためのものである
• サーバー上の現在の利用可能ストレージ容量とその使用率（パーセンテージ）。
すこし補足を上げるとすると
free --mega(RAM: メモリを見る)　-> freeはメモリ(RAM)の使用状況を確認するコマンドである
free --megaが表示するもの
total 総メモリ容量
used  使用中メモリ
free  完全に空いたメモリ
buff/cache OSがキャッシュで使っているメモリ
available  実際に利用可能なメモリ

df -m(ディスクの使用量を見る)　-> df -mはディスク(ストレージ)の使用状況を表示する
Filesystem 　　ディスクの種類
1M-blocks     総ディスク容量(MB容量)
Used　　　　　　使用中容量
Available　　　空き容量
Use%          使用率
Mounted on    マウント位置

disk_total=$(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_t += $2} END {printf ("%.1fGb\n"), disk_t/1024}')
disk_t += $2はgrepで抽出されたすべての行の$2を足し合わせて合計を作る
awkは入力された「各行」に対して処理を繰り返す
END {}で最後にまとめて出力
合計値が出たあとに、最後にprintfで出力をおこなう
printf("%.1fGb\n")->少数点ひと桁までのGBとして出力

• プロセッサの現在の使用率（パーセンテージ）。
「プロセッサの現在の使用率」　＝　CPU 使用率
　・今この瞬間 CPUがどれくらい動いているのか
　・”ロードアベレージ”ではない
　・”CPUのクロック”でもない
　・１秒間などの短時間の平均でOK
->つまりtopコマンドのCpu(s)の欄の使用率をとればOK
CPU使用率を表示するには、vmstat->システム統合情報を表示するコマンドを使用する。これにより、プロセス、メモリ使用量、CPUアクティビティ、システムステータスなどの一般的な詳細を取得することができる。
vmstat 1 2
->１：1秒ごとに　２：２回分、統計をだす
vmstatは
１．１行目にヘッダー
２.　「起動してから今までの平均」
３.　「直近１秒の状態」
を出すため、一番下の行だけ見るためにtail-1をつかっている
0  0 235424 2365020 258256 8816732    0    0    52   168 2463 2321  4  3 91  2  0
番号	値	　内容
1	0	　　　r（実行待ちプロセス数）
2	0	　　　b（ブロック中プロセス数）
3	235424   swpd（スワップ使用量）
4	2365020	 free（空きメモリ）
5	258256	 buff
6	8816732	 cache
7	0	     si（swap in）
8	0	     so（swap out）
9	52	     bi（ブロック入力）
10	168	     bo（ブロック出力）
11	2463	 in（割り込み数）
12	2321	 cs（コンテキストスイッチ数）
13	4	     us（ユーザーCPU％）
14	3	     sy（システムCPU％）
15	91	     id（アイドルCPU％ = ヒマな割合）
16	2	     wa（I/O待ち％）
17	0	     st（盗まれた時間％）
なので、15番目の値が 91 = idle の割合です。
最終的なコマンド
vmstat 1 2 | tail -1 | awk '{printf("%.1f"), 100 - $15}'
• 最後の再起動の日時。
LAST_BOOT=$(who -b | awk '$1 == "system" {print $3 " " $4}')
これは、$(...)->コマンド置換(中のコマンドの実行結果と文字列として取ってくる)
who -b | awk '$1 == "system" {print $3 " " $4}'
 ・who -b:最後にシステムがブート(起動)した日時を表示
 　例：system boot 2025-11-23 09:15
 ・awk '$1 == "system" {print $3 " " $4}'
   ・一列目が"system"の行だけを対象にして
   ・3列目（=日付）と4列目(=時刻)を" "でつないで出力する
   　-> 2025 -11 -23 09:15みたいな文字列となる
それをまるっとLAST_BOOTというシェル変数に代入している
echoの使い方
echo "Last boot: $LAST_BOOT"
 ・文字列"Last boot:"に
 ・変数LAST_BOOTの中身を展開して
 ・一行だけ表示をしている

• LVMが有効かどうか。
 ・LVMがアクティブかどうかを確認するには、lsblkコマンドを使用する。このコマンドは、すべてのブロックデバイス(ハードドライブ、SSD、メモリなど)にかんする情報を表示する。表示される情報のなかで、マネージャーの種類にlvmが含まれています。このコマンドでは、YesまたはNoを出力される情報のなかで、マネージャーの種類にlvmが含まれています。このコマンドでは、YesまたはNoを出力するため、if文を使用する。基本的に、私達がもとめている条件は、「lvm」が出現する行数を数えることである、0を超える場合はYesを、0の場合はNoを出力します。
 実装コマンド
 if [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]; then echo yes; else echo no; fi
 [ ... -gt 0 ]の条件式
 [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]
 　・「lsblk | grep "lvm" | wc -lの結果が0より大きいか？」
 　　->数値の比較でーgt(greter than)を使う
 if [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]; then
  echo yes
else
  echo no
fi
　・条件が真(LVMが１つ以上ある)　-> echo yes
　・条件が偽(LVMが1つもない)　-> echo no
　・fiはifの終わり(end if)

• アクティブな接続数。
　・ss -taって何をしているのか
　　・-t :TCPソケットだけを表示
　　・-a :「LISTEN中のもの＋確立済みのもの」など全部表示
　　　->で、そのときに右側のSTATEにLISTENとかESTABが出てくる
　・LISTENの意味
　　・サーバー側が「接続を待っている」状態
　　　・まだ相手(クライアント)とは接続されていない
　　　・ポートを開いて、「来たら受け取るよ~」と待っているだけ
　　　　・sshd(SSHサーバー)　-> 0.0.0.0:22がLISTEN
　　　　・nginx/apache -> 0.0.0.080がLISTEN
        ->イメージ：店のドアを開けて「営業中」だけど、まだお客さんは入ってきていない状態
		　例：ESTAB  0  0  192.168.0.10:ssh   192.168.0.20:52344
　　　　　　　ｰ>これは「自分の22番ポート(ssh)と、相手の52344番との間に実際の接続がはられてる」状態
　・ESTAB(=ESTABLISHED)の意味
　　ｰ>クライアントとサーバーの間で接続が確立した状態
　　　・TCPの3ウェイハンドシェイクが完了している
　　　・両方のIP・ポートが決まっていて、実際にデータを送受信している最中
　　　・ssの出力だと、ESTABと略されることが多い
　・The number of active connectionsが指しているのは、基本的にESTABだけだと思って大丈夫である。
　　・LISTEN
　　　　ｰ>ただ「ポートを開けて待っているだけ」の状態
　　　　ｰ>まだ誰と通信をしていない
　　・ESTAB
　　　　ｰ>クライアントとサーバの間でTCP接続が確立されていて、実際にデータを送受信できる状態->active connection(実際に”動いている”接続の数)
　・Apacheは「webページを配信するためのサーバーソフト」
　　・ブラウザでhttps://example.comってアクセスするとき
　　・裏側で動いて
　　　　・HTMLファイル
　　　　・画像
　　　　・CSS/JS などをクライアント（ブラウザ）に返してくれるプログラムがApacheである
• サーバーを利用しているユーザー数。
　・users | wc -w
　　ｰ>usersはログインしているユーザー名を並べて表示を行う
　　　yohya yohya ->これをwc -wに渡すと単語数(word)のカウントになる
　　ｰ>usersコマンドは：
　　　->現在ログインしている「セッション数」を表示する
　　　->1セッション＝１ログイン扱い
　　　ｰ>”同じユーザ名”でも別ログインなら別々に表示される
　　　　たとえば：
　　　　　・TTY1にログインしている
　　　　　・TTY2にもログインをしている
　　　　　・SSH接続した
　　　　ー>などの状況だと、同じユーザーが復数回表示されることがある。
　　　　　　・ローカル:yohay
　　　　　　・ssh:yohya
• サーバーのIPv4アドレスとそのMAC（メディアアクセス制御）アドレス。
　・ホストアドレスを取得するにはコマンドを使用し -> hostname -I
　・MACアドレスを取得するには　-> ip link
   ->さらにMACアドレスのみを出力するため ip link | grep "link/ether" | awk '{print $2}'
• sudoプログラムで実行されたコマンドの数。
 journalctl _COMM=sudo
 　ｰ>これはsystemdのログ(journal)から「実行したコマンド名(COMM)がsudoのログだけ」を取り出す
 　　 COMM=コマンド本体の実行ファイル名
 　　　　なので：sudoを実行したときのログだけが表示される
　... | grep COMMAND
　　COMMAND=/bin/ls
　　COMMAND=/usr/bin/apt-get update
　　COMMAND=/usr/bin/nano /etc/sudoers
　　のようなsudoによって実効されたコマンドだけ

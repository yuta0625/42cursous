構造体に関して
typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}					t_list;

構造体(struct)
構造体は、「複数のことなる型のデータをひとまとめにして扱う」ための仕組みである。
たとえば、人の情報を保存したいとき、
char name[20];
int age;
float height;
のように個別に扱うと管理が大変ですある。
これを一つの「まとまり」として扱うのが構造体である。
struct person {
	char name[20];
	int age;
	float height;
};
このように宣言を行うとつかえる。
struct person p1;
p1.age = 20;

今回の構造体である：struct s_list
typedef struct s_list
{
    void            *content;
    struct s_list   *next;
}                   t_list;

まず、struct s_list は「構造体の型名」である。
つまり、「s_list」という名前の構造体が存在するという宣言である。
<メンバ変数に関して>
構造体の中には2つのメンバがあります：
メンバ名	型	           意味
content	void *	         このノードに格納するデータ（何型でもOK）
next    struct s_list *  次のノードへのポインタ

まず、普通の構造体がある。
struct student {
    char name[20];
    int age;
};
この構造体は、「名前」と「年齢」を一人分にまとめるものである。
復数人を扱いたい場合には、配列としてまとめる。
struct student class[3];
しかし、これだと要素数が固定されていて、「あとから追加・削除が柔軟にできない」
そこで登場するのがリスト構造　(Linked List)
「一つの要素が次の要素を覚えておく」仕組みをつくると、動的に要素をつなげたり外したりできるようになる。
そのために、必要になるのが：次のノードを指すポインタ

たとえば次の構造体を考える
struct s_list
{
    void *content;
    struct s_list *next;
};
ここでnextは型がstruct s_list *である。
つまり、「自分と同じ型(=s_list構造体)へのポインタである」
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│ content=10   │ ---> │ content=20   │ ---> │ content=30   │
│ next=ptr1    │      │ next=ptr2    │      │ next=NULL    │
└──────────────┘      └──────────────┘      └──────────────┘
・１つ目の構造体は「次の構造体」をnextで指している
・２つ目の構造体は「次の構造体」をnextで指している
・最後のnextはNULLである。
各ノードが次のノードを「ポインタで覚えている」

「なぜ構造体＋ポインタ(=リンクリスト構造)を使うのか？」
配列(array)との違いを理解するのが鍵である。
Cで復数のデータを扱うときに、まず思いつくのは配列である。
int arr[3] = {10, 20, 30};
＜配列の特徴＞
・メモリが連続している  ｰ> すべての要素が隣り合って配置される
・サイズが固定  ｰ>     宣言時に要素数が決まる
・要素の追加・削除が難しい ｰ>　　真ん中に挿入すると後ろを全部ずらす必要がある
・メモリの再確保が必要   ｰ>　動的に増やすには `malloc`＋`realloc` などが必要
＜構造体＋ポインタの目的＞
リンクリストはこれと真逆の発送である。
＜リンクリストの特徴＞
・メモリが悲連続　　ｰ>　一つ一つバラバラの場所に確保されてよい
・サイズが動的　　　ｰ>　必要なときにmallocでノードを追加できる
・要素の追加・削除が簡単　ｰ>　ポインタをつなぎ替えるだけでOK
・メモリ効率が良い　ｰ>　必要なだけ確保できる（余計な領域を取らない）
＜ポインタで「次のデータの場所」を記録する＞
構造体の中に「自分と同じ型のポインタ(next)」を入れておくことで、次のデータ(ノード)の場所を覚えられる。
これにより、データ同士を鎖のように繋ぐことができるようになる。
[ノード1] → [ノード2] → [ノード3] → NULL
つまり、「必要なデータだけを好きなだけ繋げられる」ことが可能になる。

static int *int_dup(int value)
{
    int *p = (int *)malloc(sizeof(int));
    if (!p) return NULL;
    *p = value;
    return p;
}
int a = 10;
これは「スタック領域」に4バイト(intのサイズ分)のメモリを確保して、そこに10を格納する
スタック領域
┌───────┐
│ 10    │ ← a（ローカル変数）
└───────┘
この場合、aは関数が終わると一緒に消える。
mallocを使った場合
int *p = (int *)malloc(sizeof(int));
これは「ヒープ領域」にsizeof(int)を確保する
ヒープ領域                スタック領域
┌───────┐              ┌───────┐
│ ???   │ ← mallocで確保  │ p → 0x1000 │
└───────┘              └───────┘
そして次の行で
*p = value;
値を代入する。
ヒープ領域                スタック領域
┌───────┐              ┌───────┐
│ 10    │ ← (*p)       │ p → 0x1000 │
└───────┘              └───────┘
これでpが「ヒープ上のint型の領域」を指すようになる。

t_list *lst_new(void *content)
{
    t_list *node = (t_list *)malloc(sizeof(t_list));
    if (!node) return NULL;
    node->content = content;
    node->next = NULL;
    return node;
}
lst_new()関数は「新しいノード（構造体）をヒープ領域に作って返す」関数である。
t_list *node = (t_list *)malloc(sizeof(t_list));
ここでやっているのは、ヒープ領域にt_list構造体１個分のメモリを確保し、そのアドレスをnodeに渡す
sizeof(t_list)は構造体のサイズ（中のvoid *contentとstruct s_list *nextの分）で、例えば64bit環境ならポインタは８バイトなので合計で16バイト程度になる。
ヒープ領域
┌──────────────────────┐
│ content : ???        │ ← (8バイト)
│ next    : ???        │ ← (8バイト)
└──────────────────────┘
        ↑
       node（ポインタ）
node -> content = content;
contentは関数の引数で、例えば呼び出し側では下記になる
t_list *n1 = lst_new(int_dup(10));
ここでint_dup(10)はint *を返す関数である。
node->content = 10という値が入っているアドレス
ヒープ領域：
 ┌───────────────┐
 │ int(10)       │ ← int_dupで確保
 └───────────────┘
 ┌──────────────────────┐
 │ content : → (上のintのアドレス) │
 │ next    : NULL                 │
 └──────────────────────┘
スタック：
 ┌──────────────┐
 │ n1 → (上の構造体のアドレス) │
 └──────────────┘
